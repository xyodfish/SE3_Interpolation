#include "SE3TrajectoryInterpolator.h"
#include "enumUtils.h"
#include "spdlog/spdlog.h"

namespace SE3::Iterpolation {
    SE3TrajectoryInterpolator::SE3TrajectoryInterpolator(const std::vector<std::vector<double>>& trajectory,
                                                         const std::vector<double>& timeSeries, const std::string& interType)
        : trajectory_(trajectory),
          timeSeries_(timeSeries),
          interType_(interType),
          trajSize_(trajectory.size()),
          timeSeriesSize_(timeSeries.size()) {

        generateInterpolators(EnumUtils::toEnum<INTER_TYPE_ENUM>(interType_));
    }

    void SE3TrajectoryInterpolator::generateSlerpInterpolators() {

        if (trajSize_ != timeSeriesSize_) {
            throw std::invalid_argument("The trajectory and time series are not consistent.");
        }

        interpolator_ = std::make_shared<SE3InterpolationSlerp>(trajectory_, timeSeries_);
    }

    void SE3TrajectoryInterpolator::generateSquadInterpolators() {

        if (trajSize_ != timeSeriesSize_) {
            throw std::invalid_argument("The trajectory and time series are not consistent.");
        }

        interpolator_ = std::make_shared<SE3InterpolationSquad>(trajectory_, timeSeries_);
    }

    void SE3TrajectoryInterpolator::generateBezierInterpolators() {
        if (trajSize_ < 4 || ((trajSize_ - 3) != timeSeriesSize_)) {
            throw std::invalid_argument("The trajectory points or time series are not valid");
        }

        interpolator_ = std::make_shared<SE3InterpolationBezier>(trajectory_, timeSeries_);
    }

    void SE3TrajectoryInterpolator::generateInterpolators(INTER_TYPE_ENUM interType) {

        if (trajSize_ < 3 && interType_ == "SQUAD") {
            interType = INTER_TYPE_ENUM::INVALID;  // 轨迹点个数有问题，直接设置为invalid
        }

        switch (interType) {
            case INTER_TYPE_ENUM::SLERP: {
                generateSlerpInterpolators();
                spdlog::info("The slerp type is generated");
                break;
            }
            case INTER_TYPE_ENUM::SQUAD: {
                generateSquadInterpolators();
                spdlog::info("The squad type is generated");

                break;
            }
            case INTER_TYPE_ENUM::BEZIER: {
                generateBezierInterpolators();
                spdlog::info("The bezier type is generated");
                break;
            }
            default: {
                spdlog::error("The input interpolation type is not supported, the slerp type is generated by default.");
                generateSlerpInterpolators();
            } break;
        }
    }

    /// @brief get the trajectory at time t
    /// @param t
    /// @return
    Eigen::Isometry3d SE3TrajectoryInterpolator::getInterpolation(double t) { return interpolator_->getInterpolation(t); }

    std::vector<double> SE3TrajectoryInterpolator::getInterpolationVector(double t) { return interpolator_->getInterpolationVector(t); }

    /// @brief get the whole trajectory constructed by the interpolator
    /// @return
    std::vector<std::vector<double>> SE3TrajectoryInterpolator::getTrajs() { return interpolator_->getTrajs(); }

}  // namespace SE3::Iterpolation